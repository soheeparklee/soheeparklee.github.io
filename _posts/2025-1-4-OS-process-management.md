---
title: KOCW_Process Management
categories: [Computer Science, Computer Architecture/Operating System]
tags: [] # TAG names should always be lowercase
---

## ✅ 컴퓨터 시스템의 작동 개요

- CPU는 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 수행한다.
- 이 때 CPU가 수행해야 할 **메모리 주소를 담고 있는 레지스터**를 프로그램 카운터 `Program counter, PC`라고 한다.
- 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 위치의 명령을 처리한다.

## ✅ Multi Programming

- 일반적으로 CPU는 _한 개_
- 따라서 CPU에서 명령이 수행되고 있는 프로그램도 _한 개_
- 그러나 CPU가 짧은 시간 단위로 시간을 나누어 프로그램을 수행하고 ➡️ **time sharing**
- 여러 프로그램이 메모리에 동시 적재되어 있을 수 있으므로
- *"여러 프로그램이 동시에 실행된다"*라고 말할 수 있다.

## ✅ 프로그램의 실행(Memory load)

> 프로그램이 실행되고 있다. <br>
> 1️⃣ 디스크에 존재하던 실행파일이 메모리에 적재된다. <br>
> 2️⃣ 프로그램이 CPU를 할당받고 명령이 수행된다. <br>

- 프로그램은 디스크에 저장
- 실행되면 메모리에 적재
- 운영체제 커널은 메모리에 올라가 있음
- 프로그램이 메모리에 적재되면 ➡️ 프로세스

#### 1️⃣ 디스크에 존재하던 실행파일이 메모리에 적재된다.

- 사실 메모리에 프로그램이 올라가기 전에 한 단계가 더 있음
- 바로 `Virtual Memory`
- 그 프로그램만의 `address space, 독자적인 주소 공간`이 만들어진다.
- 그 `address space`를 바로 `virtual memory`라고 한다.
- 실제로는 존재하지 않음

- 각 프로그램마다 별도의 `주소 공간(코드, 데이터, 스택)`을 가지며
- 프로그램마다 독자적으로 존재하는 주소공간을 `가상 메모리` 또는 `논리적 메모리`라고 부른다.

- 실행 파일이 메모리에 적재될 때, 일부분만 올라가고
- 나머지는 디스크의 특정 영역`swap`에 내려가 있다.
- 이는 메모리 공간을 효율적으로 사용하기 위함이다.
- 그래서 지금 당장 실행되야 할 부분만 메모리에 올라가고
- 아닌 부분들은 `swap`에 올라가 있게 된다.

<img width="498" alt="Screenshot 2025-01-04 at 12 31 14" src="https://github.com/user-attachments/assets/94e87578-3dd9-476f-9167-cbb05bf532d3" />

- `address space`는 각 프로그램마다 `0~n`까지 있고 ➡️ **virtual address**
- `physical memory`는 실제 메모리로, 하나 크게 존재한다. ➡️ **physical address**
- `physical memory`의 가장 낮은 주소에 `운영체제 커널`이 올라가고, 그 위에 현재 실행될 프로그램들이 올라가게 된다.
- 따라서 **virtual address**에서 **physical address**로 **address translation**이 필요하다.

## ✅ Virtual Memory 구성 요소

- 컴퓨터 프로그램 내부는 **함수**들로 구성되어 있다.
- 그래서 하나의 함수가 실행되는 와중에 다른 함수를 호출하고, 호출된 함수의 수행이 끝나면 다시 원래 수행하던 함수로 돌아가 프로그램을 계속 실행한다.
- 한편 프로그램이 실행되기 위해서는 `해당 명령을 담은 프로그램의 주소 영역`이 메모리 위에 올라가 있어야 한다.

- `해당 명령을 담은 프로그램의 주소 영역/공간`은 `코드 code`, `데이터 data`, `스택stack`으로 구분된다.
- `code`:
  - CPU에서 수행할 기계어
  - 우리가 작성한 프로그램 함수들의 코드가 CPU에서 실행될 수 있도록 기계명령어로 변환되어 저장됨
- `data`:
  - 프로그램이 실행되다가 메모리를 사용하는 데이터(전역변수, 배열)
  - 전역 변수 `global variable`등 프로그램이 사용하는 데이터 저장
- `stack`:
  - 어떤 함수를 호출한 후 return할 곳
  - 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터 임시로 저장

## ✅ 운영체제 kernel구조

- 운영체제도 하나의 프로그램이므로, 운영체제 커널 역시 `주소 공간(코드, 데이터, 스택)`을 가진다.
- 운영체제의 목적은 `1. 아랫단의 하드웨어 자원 효율적 관리`, `2. 윗단의 응용프로그램 및 사용자에게 편리한 서비스 제공`
- ✔️ kernel `code`:
  - CPU, 메모리 등 자원 관리 부분 ➕ 사용자에게 편한 인터페이스를 제공하기 위한 부분
  - 또 시스템 콜, 인터럽트 처리 코드
  - 자원 관리 CPU scheduling, memory management위한 코드
- ✔️ kernel `data`:
  - 각 프로세스의 상태, CPU 사용 정보, 메모리 사용정보 등을 유지하기 위한 자료구조 `PCB`를 두고 있다.
  - 하드웨어, 소프트웨어를 포함해 시스템 내 모든 자원을 관리하기 위한 자료구조를 가지고 있다.
  - `PCB`: Process Table and Control Block
  - data structure used by OS to store information about specific process
  - each process has its own PCB, includes details for the OS to manage, control process
  - 현재 프로세스가 10개 실행되고 있다 ➡️ `PCB`도 10개
- ✔️ kernel `stack`:
  - 함수 호출 시 복귀주소 저장
  - 현재 실행중인 프로세스마다 **별도의** 스택을 두어 관리한다.
  - 예를 들어 `프로그램 A`가 실행되다가 운영체제를 호출하면 `stack A`에 `프로그램 A`저장해놓는 식이다

<img width="529" alt="Screenshot 2025-01-04 at 13 01 57" src="https://github.com/user-attachments/assets/ef7c83c0-ccca-4c3c-bc90-3f2f5232ee2b" />

## ✅ 사용자 프로그램이 사용하는 함수

> 사용자 정의 함수, 라이브러리 함수, 커널 함수

#### ☑️ **사용자 정의 함수**

> 프로그래머가 직접 작성한 함수

#### ☑️ **라이브러리 함수**

> 프로그래머가 직접 작성하지는 않았지만, 누군가 작성해 놓은 함수를 호출만 해서 사용하는 것

- 사용자 정의 함수와 라이브러리 함수는 모두 프로그램의 코드 영역에 기계어 명령 형태로 존대한다.
- 프로그램이 실행될 때마다 `프로세스의 주소 공간`에 포함됨
- 함수 호출 시에도 자신의 `주소 공간`에 있는 `스택` 사용

#### ☑️ **커널 함수**

> 운영체제의 커널 코드에 정의된 함수 <br>
> 커널 함수를 호출하는 것이 바로 `system call`

- 커널함수는 `운영체제 커널의 주소 공간`에 `코드` 정의

- ✔️ 커널함수의 두 종류

  - 시스템 콜 함수
  - 인터럽트 처리 함수

- 예를 들어, `삼각 함수 sin()`은 라이브러리 함수
- `printf()` 그 자체로는 라이브러리 함수지만, 궁극적으로 특권 명령인 입출력을 수반하므로 `printf()` 내에서 커널 함수를 호출하는 시스템 콜을 동반한다.
- 일반적인 함수 호출 🆚 시스템 콜
  - 일반적인 함수 호출: 사용자 프로그램 내에 존재하는 코드 실행
  - **시스템 콜**: 운영체제라는 별개의 프로그램에 CPU를 넘겨서 실행
    - CPU를 운영체제에게 넘기기 위해서 인터럽트와 통일한 메커니즘, 즉 CPU의 인터럽트 라인을 세팅하는 방법을 사용한다.

## ✅ 프로세스의 두 가지 실행 상태

- 프로세스 A가 CPU에서 실행되고 있음
- 1️⃣ 일반적인 함수 호출(자신의 주소 공간에 정의된 코드 실행) ➡️ **사용자 모드**
  - 사용자 정의함수, 라이브러리 함수 호출
  - 모드의 변경 없이 사용자 모드에서 실행 지속
- 2️⃣ 커널의 시스템 콜 함수 실행 ➡️ **커널 모드**
  - 커널모드로 진입해 커널의 주소 공간에 정의된 함수 실행

## ✅

## ✅

## ✅

## ✅

CPU
