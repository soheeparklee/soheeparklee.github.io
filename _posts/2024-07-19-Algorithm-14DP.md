---
title: Dynamic Programming
categories: [Coding Test, Algorithm]
tags: []
---

## ✅ Dynamic Programming

> solve problem by breaking down into simplwe subproblems <br>
> solve subproblem once, store the result, avoid redundand computation <br>
> find a subproblem with **repeated caculation** <br>

1. Top-Down Dynamic Programming
   - memoization
   - recursive
2. Bottom-Up Programming
   - start with solving subproblems, build up solutions to solve large problems.

#### 🆚 Divide and Conquer

- simmilar in the sence that we divide a problem to solve

- but different
  - Divide and Conquer: divide problem into smaller problem
  - DP: find a **repeated caculation(반복되는 연산)** to solve

## ⭐️ Keyword

Memoization

> store(memoize) results to avoid recomputation <br>
> 한 번 계산한 문제는 다시 계산하지 않도록 저장 <br>

## ✅ Code

- Shortest path in graph
- fibonacci
  <https://soheeparklee.github.io/posts/CT-1-57/>

## 👍🏻 Pros

- avoid recomputing
- break down into smaller problems

## 💡 Reference

<https://www.geeksforgeeks.org/dynamic-programming/> <br>
<https://gyoogle.dev/blog/algorithm/Dynamic%20Programming.html> <br>
