---
title: TCP / UDP
categories: [Computer Science, Network]
tags: [] # TAG names should always be lowercase
---

reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

## âœ… TCP

> **Transmission Control Protocol** <br>

- reliable <br>
- conection-oriented <br>
- ğŸ‘ğŸ» assure transmission of data

- exchange data when server is connected
- network congestion avoidance algorithm

- full duplex: ì „ì´ì¤‘, ì „ì†¡ ì–‘ë°©í–¥ìœ¼ë¡œ ë™ì‹œì—
- point-to-point: ì—°ê²°ì´ ì •í™•íˆ 2ê°œì˜ ì¢…ë‹¨ì ì„ ê°€ì§€ê³  ìˆìŒ

#### 1ï¸âƒ£ **Reliable**

- checksum, retransmission, ACK, timer, sequence number

ğŸ’¡ reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

#### 2ï¸âƒ£ **Connection Oriented**

- before transmission, TCP sets parameters for connection
- Thus, _pre-connection_ process before connection
- called `3-way-handshake`

<br>

- TCP operates onlt on end systems
- does not function within intermediate network elements
- routers between the ends cannot detect TCP connection
  <br>

- full-duplex
- point-to-point: one sender and one reciever, no multicasting

- to terminate connection, `4-way-handshake`

## ğŸ“Œ Reliable TCP

- provide reliable data transmission service
- in an unreliable(best-effort) IP environment
  <br>

> What is reliable transmission?
>
> > a reliable transmission is transmission where... <br>
> >
> > - data is not corrupted, <br>
> > - in the right order <br>

<br>

- TCP uses single timer
- (timer per segement would have huge overhead)

#### ğŸ«±ğŸ» TCP Sender

**1. Recieve data from application and send**

- TCP recieves data from application
- encapsulate data with segment
- send segment to IP
- If timer is not running, start timer when sending segment to IP

**2. Timer**

- If timeout, retransmit segment
- and restart timer

**3. Recieve ACK from reciever**

- compare `SendBase` and `ACK value y`
  - `SendBase`: oldest order number that has _not_ been acknowledged
  - `y`: value of `ACK`
- TCP uses sequence numbers
- `y` checks `recievement of bytes before y`
- If `y > SendBase`
  - recievement of packets from `SendBase to y-1 that has not recieved ACK` has been confirmed
  - Thus, `SendBase` changes to `y+1`
  - Sliding window
- If there is unchecked segment, restart timer

## ğŸ“Œ Retransmission Scenarios in TCP

- three scenarios might be possible for retransmission

<img width="778" alt="Screenshot 2024-09-02 at 18 33 21" src="https://github.com/user-attachments/assets/e3f362ca-6f50-449b-b52b-e6ee0f118b46">

#### âœ”ï¸ lost ACK scenario

- Reciever recieved `segment 92` successfully
- Reciever send `ACK`
- `ACK` was lost
  <br>

- timeout occurs, `segment 92` is retransmitted
- Reciever has already recieved `92`, thus throw away

#### âœ”ï¸ premature timeout

- Sender sends `segment 92`, `segment 100` to reciever
- Reciever recieved both segments successfully
- Reciever sends `ACK100`, `ACK120` accordingly
  <br>

- However, sender recieves `ACK100` **after** timeout
- Sender retransmits `segment 92`
- Sender recieve `ACK120` before timeout
- Sender does not retransmit `segment 100`

#### âœ”ï¸ cumulative ACK

- Sender sends `segment 92`, `segment 100` to reciever
- Reciever recieved, sends `ACK100`, `ACK120` accordingly
- However, `ACK100` was lost
  <br>
- Sender recieves only `ACK120`
- Sender can assume until `segment 100` was successfully recieved
- Thus, retransmission **does not occur**

#### â³ When timeout, timeout âœ–ï¸ 2

- When timeout occurs, TCP retransmits the segment with smallest order from segements that have not recieved `ACK`
- Thus, when timeout occurs, TCP makes `timeout period * 2`
- To reduce network congestion
- This is called **congestion control**

## ğŸš€ TCP fast retransmit

<img width="222" alt="Screenshot 2024-09-02 at 18 47 24" src="https://github.com/user-attachments/assets/bc20e648-7c28-4619-8c9f-2e2db66ebfe0">

- ğŸ‘ğŸ» Problem of retransmitting according to timeout:

  - retransmission according to timeout has problems too
  - when timeout period is **too long**

<br>

- Sender can realize packet corruption after `duplicate ACKs`
- When Reciever recieves segment in wrong order, sends the `last correct ACK` to sender
- If sender recieves `triple dublicate ACKs`
- sender can realize packet has been lost for that `ACK`
- sender can retransmit

<br>

- Sender does not wait for timeout,
- thus this is **fast retransmit**

## TCP ğŸ†š GBN, SR

> Is TCP GBN, or SR?

- TCP is simmilar to GBN
- Like GBN, TCP sender has to keep track of
  - `SendBase`(smallest order num without `ACK`)
  - `NextSeqnum`(next number segment to be transmitted)

<br>

- TCP is different from GBN
- If window size is `5`, sent data `1, 2, 3, 4, 5` and `ACK` for packet `2` is lost
- GBN would retransmit all `1, 2, 3, 4, 5`
- TCP would retransmit only `2`
- or, if sender recieves `ACK 3/4/5(later than 2)` before timeout, does not retransmit anything
- bc TCP uses `cumulative ACK`

<br>

- TCP is similar to SR
- that it only retransmits the lost segment(selective)

<br>

- TCP is different from SR
- However, SR uses timer for each segment
- TCP uses only one timer for the oldest segment that did not recieve `ACK`
- SR does not use `cumulative ACK`
- TCP uses `cumulative ACK`

- â­ï¸ conclusion: TCP is similar to GBN and SR, but is distinctive
- TCP is more like a hybrid GBN, SR

## â˜‘ï¸ 3 way handshake

<img width="761" alt="Screenshot 2024-09-02 at 21 34 12" src="https://github.com/user-attachments/assets/d0b83b18-e5b3-4439-95de-ab4c40899c0d">

> PAR <br>
>
> > Positive Acknowledgement with Re-transmission <br>
> > TCP provides reliable connection with PAR <br>
> > device using PAR resend the data until it recieves acknowledgement <br>

<br>

âœ”ï¸ **SYN**:

- **synchronize**
- client sends `SYN(Synchronize Sequence Number)` to server
- SYN bit = 1
- send `Sequence Number` with random num
  <br>

- Result `SYN`:
- client: port `CLOSED`
- server: `LISTEN`(port open, ready for communication)

âœ”ï¸ **SYN+ACK**:

- **synchronize acknowledge**
- server ACK client request, request client to open port as well
- server responds to client with `SYN+ACK` signals bit set
- SYN bit = 1
- `Acknowledgement Number`: `Sequence Number + 1`
- client checks that server state is `alive` with server `ACK` message
  <br>

- Result `SYN+ACK`:
- client: `CLOSED` â¡ï¸ `ESTABLISHED`(port connected)
- server: `LISTEN` â¡ï¸ `SYN_RSV`(waiting for response after SYN request)

âœ”ï¸ **ACK**:

- **acknowledge**
- client acknowledges the response of server
- client sends server `ACK` message so that server can check client and connect
- establish reliable connection
- can start exchanging data
- server checks that client state is `alive` with client `ACK` message
  <br>

- Result `ACK`:
- client: `ESTABLISHED`
- server: `ESTABLISHED`

## â˜‘ï¸ 4 way handshake

<img width="463" alt="Screenshot 2024-09-02 at 23 10 34" src="https://github.com/user-attachments/assets/fda8992b-20af-478b-8d57-160a175e20a0">

> terminate connection

âœ”ï¸ **FIN**:

- client sends `FIN` to server
- Fin bit = 1

- Result
- client: `FIN_WAIT_1`
- server: `CLOSE_WAIT`

âœ”ï¸ **ACK**:

- when server revieves `FIN`, sends `ACK` message to client
- to send all data, server is in **CLOSE_WAIT status**

- when client recieves `ACK`, change port status to `FIN_WAIT_2`
- client waits for server `FIN`

- Result
- client: `FIN_WAIT_2`
- server: `CLOSE_WAIT`

âœ”ï¸ **FIN**:

- server tells client "I finished sending data"
- if all data is sent, server send `FIN` to client
- FIN bit = 1

- Result
- client: `TIME_WAIT`
- server: `LAST_ACK`

âœ”ï¸ **ACK**:

- client recieves `FIN`, sends `ACK` message to server
- server closes after getting final `ACK`
- client closes after `TIME_WAIT`

- Result
- client: `CLOSED`
- server: `CLOSED`

## â“ Two way handshake?

> Why not use two-way-handshake?
> What are the problems of two-way-handshake

<img width="765" alt="Screenshot 2024-09-02 at 23 22 01" src="https://github.com/user-attachments/assets/fc6dbc69-839d-44b3-b817-b92fd789f527">

- Two scenarios of two-way-handshake
- 1ï¸âƒ£ Client request server for connection
- 2ï¸âƒ£ Server replies `ACK`, connection created

- However, following situations should not be connected
- ğŸ‘ğŸ» Client request that came to server is a retransmission request due to timeout
- ğŸ‘ğŸ» When client and server TCP communication is over

- Thus, server has to check `client state` before connecting to client request
- need to check if `client state` is `alive`
- client has to tell server that its state is `alive` and possible for connection

## âœ… Problems of TCP

- packet loss <br>
- packet order miss <br>
- congestion <br>
- reciever overloaded <br>

## â˜‘ï¸ Flow Control in TCP

<img width="490" alt="Screenshot 2024-09-02 at 23 26 24" src="https://github.com/user-attachments/assets/8a51a024-bca1-495a-ace4-d861e6ecd4f5">

- âš ï¸ sender speed > reciever speed <br>
- reciever recieve too much segments even before sending read data to TCP socket
- reciever buffer overflow â¡ï¸ cannot recieve more packet

- ğŸ’Š configure data **sending speed** according to reciever <br>
- configure sender's `window size`
- ensure reciever `Free Buffer Space(rwnd)` is not overflowed
- need to ensure reciever doesnt recieve too much packets <br>
- prevent reciever overflow

- reciever sends feedback of state to sender <br>
- reciever send `ACK` with `TCP header rwnd`
- with information about its `Free Buffer Space(rwnd)`

#### ğŸ’Š Solution

âœ”ï¸ **Stop and Wait**

- only send next packet when recieved message

âœ”ï¸ **Sliding window**
<img width="604" alt="Screenshot 2024-07-27 at 00 59 08" src="https://github.com/user-attachments/assets/e52725fa-128c-4f43-80bb-41601033800b">

- only can packet size according to reciever
- packet on air = sliding window
  - sliding window= last sent byte - last checked byte

## â˜‘ï¸ Congestion Control in TCP

<img width="449" alt="Screenshot 2024-09-02 at 23 32 38" src="https://github.com/user-attachments/assets/4b8870aa-f47b-408a-80cf-7333dfeb8bb2">

- prevent that **number of packet** in **network** do not overexceed
- configure `window size` to reduce network congestion
- configure host, router to prevent congestion

> What happens when network is congested? <br>
>
> > - more latency <br>
> > - packet loss <br>

#### ğŸ’Š Solution

âœ”ï¸ **AIMD**

> Additive Increase/Multiplicative Decrease

<img width="481" alt="Screenshot 2024-09-02 at 23 44 05" src="https://github.com/user-attachments/assets/e2eb2b5b-f123-4bce-9749-99ed6a65a49d">

- **Additive increase:** send `n` packet, if arrives successfully, send `n+1`
- AIMD will, for every `RTT`, increase `cwnd` for `1`
- **Multiplicative decrease:** if fail, packet send speed `/2`

<br>
<br>

âœ”ï¸ **Slow Start**

<img width="417" alt="Screenshot 2024-09-02 at 23 51 27" src="https://github.com/user-attachments/assets/2ce2c063-03ca-4ac2-80eb-6197634ce7fd">

- For each `RTT`, send `n` packet, if arrives successfully, send `n*2`
- double `cwnd`
- If `cwnd` **>** `ssthresh(OS threshold)`
- then for each `RTT`, increase `cwnd` for `1`
- this moment is called the `slow start phrase`
- if packet loss, make `ssthresh = current cwnd/2`
- packet loss can be detected with `3 duplicate ACK` or `timeout`

<br>
<br>

âœ”ï¸ **Fast Retransmit**

- if reciever recieves the wrong packet, send ACK
- but in this ACK, send the number of packet that reciever missed to recieve
- sender will acknowledge he didnt sent this packet, and send.
- if repeated w same number packet more than three times, reduce `window size`

âœ”ï¸ **Fast Recovery**

- if congestion, increase `window size`

âœ”ï¸ **TCP Tahoe**

- If packet loss is detected, make `cwnd` to `1`

âœ”ï¸ **TCP RENO**

- If packet loss is detected, make `cwnd` to `cwnd/2`(half)
- widely used method

## Flow control ğŸ†š Congestion control

âœ”ï¸ **Flow control:**

- control traffic from sender to reciever
- protect reciever overflow
- usually data link layer

âœ”ï¸ **Congestion control:**

- control congestion on network
- prevent network from congestion
- usually network, transport layer

## âœ… UDP

> **User Datagram Protocol** <br>
> manage data in datagram unit <br>

<img width="556" alt="Screenshot 2024-09-01 at 14 43 46" src="https://github.com/user-attachments/assets/a5b94567-1af9-48f7-a6d6-24fe702a7daf">

- conectionless <br>
- NOT reliable (transmission not granted) <br>
- ğŸ‘ğŸ» speed

- data might arrive in different order from sent order
- does not check if data was recieved
- no flow control
- no logical connection between client and server(no handshake)
- packets are independent

- 1:1
- 1:N
- N:N

<br>

> ğŸ‘ğŸ» Why use UDP?
>
> > Faster than TCP
> > UDP header is simple too
> > used for for real time services

<br>

> Why does **Domain Name Service** use UDP?
>
> > - DNS: application layer protocol
> > - DNS request is small â¡ï¸ small enough to be stored inside UDP segment
> > - do not need 3 way handshake(TCP overhead > UDP overhead)
> > - loss for request will be configured by application layer

<br>

> When does DNS have to use TCP?
>
> > zone transfer(request between DNS servers)
> > if data is bigger than 512 bytes

#### 1ï¸âƒ£ **Not reliable**

- data can be lost
- data can be revieced in different order
- can check data integrity: with `checksum header`
- if reliability is needed, compliment reliability in application level
  <br>

â­ï¸ **UDP** `checksum header`

- purpose: verify data integrity
- divide UDP data segment into word(16bit)
- add each word, add 1, create checksum
- send segment with UDP `checksum header`
- recipient recieve segment, create checksum on recieved segemnt
- check if recieved checksum matches
- if matches, the segment has not been altered

#### 2ï¸âƒ£ **Connectionless**

- no pre-connection process, no handshake
- faster

#### 3ï¸âƒ£ **faster speed, less overhead**

- no reliability, no connection â¡ï¸ fast
- less overhead

  - TCP: 20byte overhead
  - UDP: 8byte overhead
    <br>

- used in **DNS, SNMP**, streaming service
- **DNS**:
  - purpose is to get IP address to domain name
  - use UDP for speed
  - and UDP less overhead
- **SNMP**:
  - simple network management protocol
  - network device can be numerous
  - UDP is more adequate, less overhead and faster speed
- internet calls, streaming service:
  - minimum transmission guaranteed
  - allow little data loss
  - thus, UDP is adequate

## TCP ğŸ†š UDP

<img width="824" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-01-06 á„‹á…©á„’á…® 5 58 08" src="https://github.com/soheeparklee/portfolioWebsite_dreamcoding/assets/97790983/2386982e-10dc-46d7-9117-41f473cb3a68">

- ê³µí†µì :
- way to establish connection
- unit of transport layer: segment

### â˜‘ï¸ TCP: Transmission Control Protocol

- ì˜ˆì˜ë°”ë¥¸ í”„ë¡œí† ì½œ<br>
- "ë°ì´í„° ì „ì†¡í•´ë„ ë ê¹Œìš”?" ë¬¼ì–´ë³´ê³  ë¬¸ì œ ì—†ë‹¤ê³  í•˜ë©´ ê·¸ì œì•¼ ë³´ëƒ„.<br>
- ë³´ë‚¸ í›„ "ê°ì‚¬í•©ë‹ˆë‹¤" ì¸ì‚¬ê¹Œì§€ í•˜ê³  ë¬¼ëŸ¬ê°„ë‹¤.<br>

- ì—°ê²° ì§€í–¥í˜• í”„ë¡œí† ì½œ <br>
- ë°ì´í„° **ì•ˆì •ì„±**ì„ ìœ„í•´ **ì‹ ë¢°ì„±/íë¦„**ì„ ì œì–´í•˜ëŠ” ì „ì†¡ ê³„ì¸µ í”„ë¡œí† ì½œ <br>
- UDPì— ë¹„í•´ì„œëŠ” ëŠë¦¼ <br>
- ì •í™•ì„± í•„ìš”í•˜ë©´ TCP <br>

#### ğŸ’¡ ì—°ê²°ê³¼ì • 3-way-handshake

1. SYN: ë‚˜ ë°ì´í„° ë³´ë‚´ë„ ë¼?<br>
2. SYN/ACK: ì‘ ë³´ë‚´<br>
3. ACK: ê·¸ì œì•¼ ë°ì´í„° ë³´ë‚¸ë‹¤.<br>

#### ğŸ’¡ ë°ì´í„° ì†¡ìˆ˜ì§„ ì‹œ ë™ì‘

1. ë°ì´í„°(íŒ¨í‚·) ìˆœì„œ ë³´ì¥ <br>
2. ë°ì´í„° íë¦„ ì œì–´ <br>
3. ë°ì´í„° ì‹ ë¢°ì„± ë³´ì¥(ì¬ì „ì†¡) <br>

#### ğŸ’¡ ì—°ê²° í•´ì œ ê³¼ì • 4-way-handshake

1. FIN <br>
2. ACK <br>
3. FIN <br>
4. ACK í•˜ê³  ë‚˜ì„œì•¼ ì—°ê²° í•´ì œ <br>

### â˜‘ï¸ UDP: User Datagram Protocol

ë§‰ë¬´ê°€ë‚´ í”„ë¡œí† ì½œ<br>
ê·¸ëƒ¥ ì¼ë‹¨ ë°ì´í„° ë³´ëƒ„.<br>
ë°›ìœ¼ë©´ ë°›ëŠ”ê±°ê³  ì•ˆ ë°›ìœ¼ë©´ ì•ˆ ë°›ëŠ”ê²¨~<br>
<br>
ë°ì´í„° ì‹ ë¢°ì„±ë³´ë‹¤ëŠ” **ì†ë„ì™€ ê°„ë‹¨í•œ í†µì‹ ì„** ì¤‘ì‹œí•˜ëŠ” ì „ì†¡ê³„ì¸µ í”„ë¡œí† ì½œ<br>
ì†ë„ ì¤‘ìš”í•˜ë©´ UDP<br>

- ì—°ê²°ê³¼ì • 3-way-handã…œshake **ìƒëµ**<br>
- ë°ì´í„°(íŒ¨í‚·) ìˆœì„œ ë³´ì¥ âŒ<br>
- ë°ì´í„° íë¦„ ì œì–´ âŒ<br>
- ë°ì´í„° ì‹ ë¢°ì„± ë‚®ìŒ<br>
- ì—°ê²° í•´ì œ ê³¼ì • 4-way-handshake **ìƒëµ**<br>
