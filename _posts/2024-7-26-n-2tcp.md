---
title: TCP / UDP
categories: [Computer Science, Network]
tags: [] # TAG names should always be lowercase
---

reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

## âœ… TCP

> **Transmission Control Protocol** <br>

- reliable <br>
- conection-oriented <br>
- ğŸ‘ğŸ» assure transmission of data

- exchange data when server is connected
- network congestion avoidance algorithm

- full duplex: ì „ì´ì¤‘, ì „ì†¡ ì–‘ë°©í–¥ìœ¼ë¡œ ë™ì‹œì—
- point-to-point: ì—°ê²°ì´ ì •í™•íˆ 2ê°œì˜ ì¢…ë‹¨ì ì„ ê°€ì§€ê³  ìˆìŒ

#### 1ï¸âƒ£ **Reliable**

- checksum, retransmission, ACK, timer, sequence number

ğŸ’¡ reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

#### 2ï¸âƒ£ **Connection Oriented**

- before transmission, TCP sets parameters for connection
- Thus, _pre-connection_ process before connection
- called `3-way-handshake`

<br>

- TCP operates onlt on end systems
- does not function within intermediate network elements
- routers between the ends cannot detect TCP connection
  <br>

- full-duplex
- point-to-point: one sender and one reciever, no multicasting

- to terminate connection, `4-way-handshake`

## ğŸ“Œ

## â˜‘ï¸ 3 way handshake

![Screenshot 2024-07-27 at 00 19 01](https://github.com/user-attachments/assets/ffd47985-b081-441c-b9f6-0461143fd69e)

> Positive Acknowledgement with Re-transmission <br>
>
> > TCP provides reliable connection with PAR <br>
> > device using PAR resend the data until it recieves acknowledgement <br>

<br>

- **SYN**: synchronize
  - client sends `SYN(Synchronize Sequence Number)` to server
  - start communication
- **SYN-ACK**: synchronize acknowledge
  - server responds to client with `SYN-ACK` signals bit set
- **ACK**: acknowledge
  - client acknowledges the response of server
  - establish reliabel connection

## â˜‘ï¸ 4 way handshake

![image](https://github.com/user-attachments/assets/cadd0f6e-ba3a-4425-af69-bb99da4c703e)

> terminate connection

- **FIN**
  - client sends `FIN` to server
- **ACK**
  - server revieves `FIN`, sends ACK message to client
  - to send all data, server is in **CLOSE_WAIT status**
- **FIN**
  - if all data is sent, send `FIN` to client
- **ACK**
  - client recieves `FIN`, sens `ACK` message to server
  - server closes after getting `ACK`
  - client closes after `TIME_WAIT`

## âœ… Problems of TCP

- packet loss <br>
- packet order miss <br>
- congestion <br>
- reviever overloaded <br>

## â˜‘ï¸ Flow Control in TCP

- âš ï¸ sender speed > reciever speed <br>
- configure data **speed** according to reciever <br>
- need to ensure reciever doesnt recieve too much packets <br>
- prevent reciever overflow
- reciever sends feedback of state to sender <br>

### ğŸ’Š Solution

1. **Stop and Wait**

- only send next packet when recieved message

2. **Sliding window**
   <img width="604" alt="Screenshot 2024-07-27 at 00 59 08" src="https://github.com/user-attachments/assets/e52725fa-128c-4f43-80bb-41601033800b">

- only can packet size according to reciever
- packet on air = sliding window
  - sliding window= last sent byte - last checked byte

## â˜‘ï¸ Congestion Control in TCP

- prevent that **number of packet** in network do not overexceed
- configure host, router to prevent congestion

### ğŸ’Š Solution

1. **AIMD**(Additive Increase/Multiplicative Decrease)

- send `n` packet, if arrives successfully, send `n+1`
- if fail, packet send speed `/2`

2. **Slow Start**

- send `n` packet, if arrives successfully, send `n+1`
- if fail, `window size =1`(ì—¬ê¸°ì„œ ë§í•˜ëŠ” ìœˆë„ìš°ëŠ” ìŠ¬ë¼ì´ë”© ìœˆë„ìš°)

3. **Fast Retransmit**

- if reciever recieves the wrong packet, send ACK
- but in this ACK, send the number of packet that reciever missed to recieve
- sender will acknowledge he didnt sent this packet, and send.
- if repeated w same number packet more than three times, reduce `window size`

4. **Fast Recovery**

- if congestion, increase `window size`

## âœ… UDP

> **User Datagram Protocol** <br>
> manage data in datagram unit <br>

<img width="556" alt="Screenshot 2024-09-01 at 14 43 46" src="https://github.com/user-attachments/assets/a5b94567-1af9-48f7-a6d6-24fe702a7daf">

- conectionless <br>
- NOT reliable (transmission not granted) <br>
- ğŸ‘ğŸ» speed

- data might arrive in different order from sent order
- does not check if data was recieved
- no flow control
- no logical connection between client and server(no handshake)
- packets are independent

- 1:1
- 1:N
- N:N

<br>

> ğŸ‘ğŸ» Why use UDP?
>
> > Faster than TCP
> > UDP header is simple too
> > used for for real time services

<br>

> Why does **Domain Name Service** use UDP?
>
> > - DNS: application layer protocol
> > - DNS request is small â¡ï¸ small enough to be stored inside UDP segment
> > - do not need 3 way handshake(TCP overhead > UDP overhead)
> > - loss for request will be configured by application layer

<br>

> When does DNS have to use TCP?
>
> > zone transfer(request between DNS servers)
> > if data is bigger than 512 bytes

#### 1ï¸âƒ£ **Not reliable**

- data can be lost
- data can be revieced in different order
- can check data integrity: with `checksum header`
- if reliability is needed, compliment reliability in application level
  <br>

â­ï¸ **UDP** `checksum header`

- purpose: verify data integrity
- divide UDP data segment into word(16bit)
- add each word, add 1, create checksum
- send segment with UDP `checksum header`
- recipient recieve segment, create checksum on recieved segemnt
- check if recieved checksum matches
- if matches, the segment has not been altered

#### 2ï¸âƒ£ **Connectionless**

- no pre-connection process, no handshake
- faster

#### 3ï¸âƒ£ **faster speed, less overhead**

- no reliability, no connection â¡ï¸ fast
- less overhead

  - TCP: 20byte overhead
  - UDP: 8byte overhead
    <br>

- used in **DNS, SNMP**, streaming service
- **DNS**:
  - purpose is to get IP address to domain name
  - use UDP for speed
  - and UDP less overhead
- **SNMP**:
  - simple network management protocol
  - network device can be numerous
  - UDP is more adequate, less overhead and faster speed
- internet calls, streaming service:
  - minimum transmission guaranteed
  - allow little data loss
  - thus, UDP is adequate

## TCP ğŸ†š UDP

<img width="824" alt="á„‰á…³á„á…³á„…á…µá†«á„‰á…£á†º 2024-01-06 á„‹á…©á„’á…® 5 58 08" src="https://github.com/soheeparklee/portfolioWebsite_dreamcoding/assets/97790983/2386982e-10dc-46d7-9117-41f473cb3a68">

- ê³µí†µì :
- way to establish connection
- unit of transport layer: segment

### â˜‘ï¸ TCP: Transmission Control Protocol

- ì˜ˆì˜ë°”ë¥¸ í”„ë¡œí† ì½œ<br>
- "ë°ì´í„° ì „ì†¡í•´ë„ ë ê¹Œìš”?" ë¬¼ì–´ë³´ê³  ë¬¸ì œ ì—†ë‹¤ê³  í•˜ë©´ ê·¸ì œì•¼ ë³´ëƒ„.<br>
- ë³´ë‚¸ í›„ "ê°ì‚¬í•©ë‹ˆë‹¤" ì¸ì‚¬ê¹Œì§€ í•˜ê³  ë¬¼ëŸ¬ê°„ë‹¤.<br>

- ì—°ê²° ì§€í–¥í˜• í”„ë¡œí† ì½œ <br>
- ë°ì´í„° **ì•ˆì •ì„±**ì„ ìœ„í•´ **ì‹ ë¢°ì„±/íë¦„**ì„ ì œì–´í•˜ëŠ” ì „ì†¡ ê³„ì¸µ í”„ë¡œí† ì½œ <br>
- UDPì— ë¹„í•´ì„œëŠ” ëŠë¦¼ <br>
- ì •í™•ì„± í•„ìš”í•˜ë©´ TCP <br>

#### ğŸ’¡ ì—°ê²°ê³¼ì • 3-way-handshake

1. SYN: ë‚˜ ë°ì´í„° ë³´ë‚´ë„ ë¼?<br>
2. SYN/ACK: ì‘ ë³´ë‚´<br>
3. ACK: ê·¸ì œì•¼ ë°ì´í„° ë³´ë‚¸ë‹¤.<br>

#### ğŸ’¡ ë°ì´í„° ì†¡ìˆ˜ì§„ ì‹œ ë™ì‘

1. ë°ì´í„°(íŒ¨í‚·) ìˆœì„œ ë³´ì¥ <br>
2. ë°ì´í„° íë¦„ ì œì–´ <br>
3. ë°ì´í„° ì‹ ë¢°ì„± ë³´ì¥(ì¬ì „ì†¡) <br>

#### ğŸ’¡ ì—°ê²° í•´ì œ ê³¼ì • 4-way-handshake

1. FIN <br>
2. ACK <br>
3. FIN <br>
4. ACK í•˜ê³  ë‚˜ì„œì•¼ ì—°ê²° í•´ì œ <br>

### â˜‘ï¸ UDP: User Datagram Protocol

ë§‰ë¬´ê°€ë‚´ í”„ë¡œí† ì½œ<br>
ê·¸ëƒ¥ ì¼ë‹¨ ë°ì´í„° ë³´ëƒ„.<br>
ë°›ìœ¼ë©´ ë°›ëŠ”ê±°ê³  ì•ˆ ë°›ìœ¼ë©´ ì•ˆ ë°›ëŠ”ê²¨~<br>
<br>
ë°ì´í„° ì‹ ë¢°ì„±ë³´ë‹¤ëŠ” **ì†ë„ì™€ ê°„ë‹¨í•œ í†µì‹ ì„** ì¤‘ì‹œí•˜ëŠ” ì „ì†¡ê³„ì¸µ í”„ë¡œí† ì½œ<br>
ì†ë„ ì¤‘ìš”í•˜ë©´ UDP<br>

- ì—°ê²°ê³¼ì • 3-way-handã…œshake **ìƒëµ**<br>
- ë°ì´í„°(íŒ¨í‚·) ìˆœì„œ ë³´ì¥ âŒ<br>
- ë°ì´í„° íë¦„ ì œì–´ âŒ<br>
- ë°ì´í„° ì‹ ë¢°ì„± ë‚®ìŒ<br>
- ì—°ê²° í•´ì œ ê³¼ì • 4-way-handshake **ìƒëµ**<br>
