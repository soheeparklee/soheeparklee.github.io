---
title: TCP / UDP
categories: [Computer Science, Network]
tags: [] # TAG names should always be lowercase
---

reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

## ✅ TCP

> **Transmission Control Protocol** <br>

- reliable <br>
- conection-oriented <br>
- 👍🏻 assure transmission of data

- exchange data when server is connected
- network congestion avoidance algorithm

- full duplex: 전이중, 전송 양방향으로 동시에
- point-to-point: 연결이 정확히 2개의 종단점을 가지고 있음

#### 1️⃣ **Reliable**

- checksum, retransmission, ACK, timer, sequence number

💡 reliable connection <https://soheeparklee.github.io/posts/n-reliableconnection/#-reliable-transmission>

#### 2️⃣ **Connection Oriented**

- before transmission, TCP sets parameters for connection
- Thus, _pre-connection_ process before connection
- called `3-way-handshake`

<br>

- TCP operates onlt on end systems
- does not function within intermediate network elements
- routers between the ends cannot detect TCP connection
  <br>

- full-duplex
- point-to-point: one sender and one reciever, no multicasting

- to terminate connection, `4-way-handshake`

## 📌

## ☑️ 3 way handshake

![Screenshot 2024-07-27 at 00 19 01](https://github.com/user-attachments/assets/ffd47985-b081-441c-b9f6-0461143fd69e)

> Positive Acknowledgement with Re-transmission <br>
>
> > TCP provides reliable connection with PAR <br>
> > device using PAR resend the data until it recieves acknowledgement <br>

<br>

- **SYN**: synchronize
  - client sends `SYN(Synchronize Sequence Number)` to server
  - start communication
- **SYN-ACK**: synchronize acknowledge
  - server responds to client with `SYN-ACK` signals bit set
- **ACK**: acknowledge
  - client acknowledges the response of server
  - establish reliabel connection

## ☑️ 4 way handshake

![image](https://github.com/user-attachments/assets/cadd0f6e-ba3a-4425-af69-bb99da4c703e)

> terminate connection

- **FIN**
  - client sends `FIN` to server
- **ACK**
  - server revieves `FIN`, sends ACK message to client
  - to send all data, server is in **CLOSE_WAIT status**
- **FIN**
  - if all data is sent, send `FIN` to client
- **ACK**
  - client recieves `FIN`, sens `ACK` message to server
  - server closes after getting `ACK`
  - client closes after `TIME_WAIT`

## ✅ Problems of TCP

- packet loss <br>
- packet order miss <br>
- congestion <br>
- reviever overloaded <br>

## ☑️ Flow Control in TCP

- ⚠️ sender speed > reciever speed <br>
- configure data **speed** according to reciever <br>
- need to ensure reciever doesnt recieve too much packets <br>
- prevent reciever overflow
- reciever sends feedback of state to sender <br>

### 💊 Solution

1. **Stop and Wait**

- only send next packet when recieved message

2. **Sliding window**
   <img width="604" alt="Screenshot 2024-07-27 at 00 59 08" src="https://github.com/user-attachments/assets/e52725fa-128c-4f43-80bb-41601033800b">

- only can packet size according to reciever
- packet on air = sliding window
  - sliding window= last sent byte - last checked byte

## ☑️ Congestion Control in TCP

- prevent that **number of packet** in network do not overexceed
- configure host, router to prevent congestion

### 💊 Solution

1. **AIMD**(Additive Increase/Multiplicative Decrease)

- send `n` packet, if arrives successfully, send `n+1`
- if fail, packet send speed `/2`

2. **Slow Start**

- send `n` packet, if arrives successfully, send `n+1`
- if fail, `window size =1`(여기서 말하는 윈도우는 슬라이딩 윈도우)

3. **Fast Retransmit**

- if reciever recieves the wrong packet, send ACK
- but in this ACK, send the number of packet that reciever missed to recieve
- sender will acknowledge he didnt sent this packet, and send.
- if repeated w same number packet more than three times, reduce `window size`

4. **Fast Recovery**

- if congestion, increase `window size`

## ✅ UDP

> **User Datagram Protocol** <br>
> manage data in datagram unit <br>

<img width="556" alt="Screenshot 2024-09-01 at 14 43 46" src="https://github.com/user-attachments/assets/a5b94567-1af9-48f7-a6d6-24fe702a7daf">

- conectionless <br>
- NOT reliable (transmission not granted) <br>
- 👍🏻 speed

- data might arrive in different order from sent order
- does not check if data was recieved
- no flow control
- no logical connection between client and server(no handshake)
- packets are independent

- 1:1
- 1:N
- N:N

<br>

> 👍🏻 Why use UDP?
>
> > Faster than TCP
> > UDP header is simple too
> > used for for real time services

<br>

> Why does **Domain Name Service** use UDP?
>
> > - DNS: application layer protocol
> > - DNS request is small ➡️ small enough to be stored inside UDP segment
> > - do not need 3 way handshake(TCP overhead > UDP overhead)
> > - loss for request will be configured by application layer

<br>

> When does DNS have to use TCP?
>
> > zone transfer(request between DNS servers)
> > if data is bigger than 512 bytes

#### 1️⃣ **Not reliable**

- data can be lost
- data can be revieced in different order
- can check data integrity: with `checksum header`
- if reliability is needed, compliment reliability in application level
  <br>

⭐️ **UDP** `checksum header`

- purpose: verify data integrity
- divide UDP data segment into word(16bit)
- add each word, add 1, create checksum
- send segment with UDP `checksum header`
- recipient recieve segment, create checksum on recieved segemnt
- check if recieved checksum matches
- if matches, the segment has not been altered

#### 2️⃣ **Connectionless**

- no pre-connection process, no handshake
- faster

#### 3️⃣ **faster speed, less overhead**

- no reliability, no connection ➡️ fast
- less overhead

  - TCP: 20byte overhead
  - UDP: 8byte overhead
    <br>

- used in **DNS, SNMP**, streaming service
- **DNS**:
  - purpose is to get IP address to domain name
  - use UDP for speed
  - and UDP less overhead
- **SNMP**:
  - simple network management protocol
  - network device can be numerous
  - UDP is more adequate, less overhead and faster speed
- internet calls, streaming service:
  - minimum transmission guaranteed
  - allow little data loss
  - thus, UDP is adequate

## TCP 🆚 UDP

<img width="824" alt="스크린샷 2024-01-06 오후 5 58 08" src="https://github.com/soheeparklee/portfolioWebsite_dreamcoding/assets/97790983/2386982e-10dc-46d7-9117-41f473cb3a68">

- 공통점:
- way to establish connection
- unit of transport layer: segment

### ☑️ TCP: Transmission Control Protocol

- 예의바른 프로토콜<br>
- "데이터 전송해도 될까요?" 물어보고 문제 없다고 하면 그제야 보냄.<br>
- 보낸 후 "감사합니다" 인사까지 하고 물러간다.<br>

- 연결 지향형 프로토콜 <br>
- 데이터 **안정성**을 위해 **신뢰성/흐름**을 제어하는 전송 계층 프로토콜 <br>
- UDP에 비해서는 느림 <br>
- 정확성 필요하면 TCP <br>

#### 💡 연결과정 3-way-handshake

1. SYN: 나 데이터 보내도 돼?<br>
2. SYN/ACK: 응 보내<br>
3. ACK: 그제야 데이터 보낸다.<br>

#### 💡 데이터 송수진 시 동작

1. 데이터(패킷) 순서 보장 <br>
2. 데이터 흐름 제어 <br>
3. 데이터 신뢰성 보장(재전송) <br>

#### 💡 연결 해제 과정 4-way-handshake

1. FIN <br>
2. ACK <br>
3. FIN <br>
4. ACK 하고 나서야 연결 해제 <br>

### ☑️ UDP: User Datagram Protocol

막무가내 프로토콜<br>
그냥 일단 데이터 보냄.<br>
받으면 받는거고 안 받으면 안 받는겨~<br>
<br>
데이터 신뢰성보다는 **속도와 간단한 통신을** 중시하는 전송계층 프로토콜<br>
속도 중요하면 UDP<br>

- 연결과정 3-way-handㅜshake **생략**<br>
- 데이터(패킷) 순서 보장 ❌<br>
- 데이터 흐름 제어 ❌<br>
- 데이터 신뢰성 낮음<br>
- 연결 해제 과정 4-way-handshake **생략**<br>
