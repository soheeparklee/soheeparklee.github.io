---
title: PART6_Switch & VLAN
categories: [Computer Science, CISCO networking]
tags: [cs]
---

## 1️⃣ STP_Spanning Tree Protocol <br>

 <br>
스위치나 브리지에서 발생하는 루핑을 막아주기 위한 프로토콜 <br>
스위치나 브리지 구성에서 출발지부터 목적지까지 경로가 2개 이상 존재할 때 <br>
1개만 남겨주고 하나는 끊어 두었다가 <br>
사용하던 경로에 문제가 생기면 그 때 끊어두었던 경로를 하나씩 살림 <br>

### 💡 STP 구성 단계 <br>

🟥 루트 브리지 뽑기 <br>
🟨 루트 포트 뽑기 <br>
🟩 데지그네이티드 포트 뽑기 <br>

## 2️⃣ 브리지 ID, Path Cost

### 브리지 ID

브리지나 스위치가 통신할 때 서로를 확인하기 위해 가지고 있는 번호 <br>

```
                전체 8바이트(64비트)
    Bridge Priority   +    Mac Address
    2바이트(16비트)         6바이트(48비트)
```

### Path Cost

한 스위치에서 다른 스위치로 가는데 드는 비용 <br>
Path Cost 속도 빠를수록⬆️ 값은 작다⬇️(그만큼 노력은 덜 든다) <br>

## 3️⃣ STP 기본 규칙

### 루트 포트와 데지그네이티드 포트만 살릴거야

STP 프로토콜은 다음과 같은 기본 규칙을 적용해서 어느 쪽 링크를 살릴지, 끊을지 결정한다. <br>
STP는 **루트 포트**와 **데지그네이티드 포트**만 살려두고 나머지 포트는 다 끊어버림 ☠️ <br>
❓ 루트 포트와 데지그네이티드 포트 뽑는 목적: 어떤 포트를 살릴지 결정하기 위해 <br>

### **첫째,** 네트워크당 하나의 루트 브리지를 가진다.

루트 브리지: 기준이 되는 브리지 <br>
네트워크: 라우터로 구분되는 브로드캐스트 도메인 <br>

### **둘째,** 루트 브리지가 아닌 나머지 모든 브리지는 무조건 하나씩의 루트 포트를 갖는다.

Non Root Bridge: 루트 브리지가 아닌 나머지 모든 브리지 <br>
루트 포트: 루트 브리지랑 연결할 수 있는 가장 가까운(빠른) 포트 <br>

### **셋째,** 세그먼트 당 하나씩의 데지그네이티드 포트를 갖는다.

세그먼트: 브리지 또는 스위치 간에 서로 연결된 링크 <br>
Designated Port: 지정 포트 <br>
브리지나 스위치가 서로 연결되어 있을 때 이 세그먼트에서 한 포트는 무조건 Designated Port로 선출되어야 한다. <br>

## 4️⃣ BPDU

### BPDU(Bridge Protocol Data Unit): 루트 포트와 데지그네이티드 포트 정보 실어나르는 역할

BPDU: 스패닝 트리에 대한 정보를 담고 있으면서 매 2초에 한 번씩 뿌려지는 프레임<br>
다음과 같은 정보들을 실어 나른다.<br>
스위치는 BPDU를 주고 받으며 누구를 루트 포트, 데지그네이티드 포트로 뽑을지 정함.<br>
그래서 결국 스패닝 트리 정보를 주고받아 스패닝 트리 완성하기 위함<br>
<br>

- Root BID: 루트 브리지의 bridge id<br>
- Root Path Cost: 루트 브리지까지 가는 경로값<br>
- Sender BID: 보내는 브리지의 Sender bridge id<br>
- Port ID: 어떤 포트에서 보냈ㄲ는지 알게 해주는 아이디<br>

## 5️⃣ 누가 힘이 더 센가? 동점일 때 4단계로 순서 정하기 💪🏻

누가 루트 브리지, 루트 포트와 데지그네이티드 포트될지 정할 때 동점이면 정하기 순서가 필요하다. <br>
**1단계:** 누가 더 작은 Root BID를 가졌는가? <br>
**2단계:** 루트 브리지까지 Root Path Cost값은 누가 더 작은가? <br>
**3단계:** 누구의 Sender BID(나의 BID)가 더 낮은가? <br>
**4단계:** 누구의 Port ID가 더 낮은가? <br>

## 🟥 Root Bridge 뽑기

🔴 부팅(전원 켜져서 스위치 작동 시작) <br>
🟠 스위치끼리 BPDU 주고받기 시작 <br>
🟡 Root BID안에 자신의 BID 넣어서 전송(내가 제일 BID 낮겠지? 내가 루트 브리지겠징? 😚) <br>
🟢 근데 다른 스위치의 BID가 나의 BID보다 낮다면 상대를 루트 브리지로 인정 (너가 대장 맞네^^🫡) <br>
<br>

### 만약 특정 스위치를 꼭 루트 브리지로 만들고 싶다면?

그래서 브리지 ID안에 Bridge Priority가 있는 것이다. <br>
Bridge Priority를 다른 스위치들의 값보다 작은 값으로 만들면, 뒤에 맥 어드레스가 어떻든 그 스위치가 가장 낮은 BID를 가질 것이다. <br>

## 🟨 Non Root Bridge의 루트 포트 선출기

Root Bridge는 이미 정해졌고, 그럼 포트끼리 이제 경쟁 시작 <br>
Root Bridge가 아닌 Non Root Bridge라면 무조건 루트 포트 하나 있어야 한다. <br>
<br>
**Root Path Cost:** 루트 브리지에서 가장 가까이 있는 포트 <br>
포트 중에서 가장 Root Path Cost가 작은 포트가 루트 포트가 된다. <br>
🟰 루트 브리지까지의 Path Cost가 가장 작은 포트가 루트 포트가 된다. <br>

## 🟩 스패닝 트리의 마지막 단계: 데지그네이티드 포트(Designated Port) 뽑기

세그먼트당 반드시 한 개의 데지그네이티드 포트가 있어야 함. <br>
루트 포트는 되지 못했지만, 데지그네이티드 포트라도 되어 보겠어! <br>
세그먼트 상에서 Root Path Cost(루트 브리지까지의 Path Cost)를 비교해 더 작은 값을 가진 포트가 데지그네이티드 포트가 된다. <br>
⭐️ 루트 브리지의 모든 포트들은 언젠가 데지그네이티드 포트로 선정 <br>
(루트 브리지에서 루트 브리지까지 거리는 0이니까^^ 제일 작을수밖에 없음) <br>
<br>
❓ 만약 한 세그먼트의 두 포트에서 Root Path Cost가 같다면? <br>
이렇게 동점이 생겼을 때는 **동점일 때 4단계로 순서 정하기** 사용 <br>
<br>

🟪 **Non Designated Port:** 데지그네이티드 포트로도 선정되지 않은 포트들은 Non Designated Port가 된다. <br>

## 6️⃣ 스패닝 트리 프로토콜의 5가지 상태 변화

### ✔️ Disabled

포트가 고장나서 사용 불가 <br>
네트워크 관리자가 포트 shutDown <br>

- 데이터 전송 가능? ❌ <br>
- 맥 어드레스 배울 수 있는가? ❌ <br>
- BPDU주고 받는가? ❌ <br>

### ✔️ Blocking

스위치를 막 부팅(켰음) <br>
Disabled된 포트를 살림 <br>
Blocking 상태의 포트로 접어들면 BPDU주고 받기 시작 <br>
BPDU주고 받으면서 차례대로 루트 브리지, 루트 포트, 데지그네이티드 포트 뽑고, non designated port뽑음 <br>

- 데이터 전송 가능? ❌ <br>
- 맥 어드레스 배울 수 있는가? ❌ <br>
- BPDU주고 받는가? ⭕️ <br>

### ✔️ Listening

이제 루트 브리지, 루트 포트, 데지그네이티드 포트, non designated port까지 다 선정되었음 <br>
그러면 이제 포트는 Listening 상태로 넘어감 <br>
<br>

- 데이터 전송 가능? ❌ <br>
- 맥 어드레스 배울 수 있는가? ❌ <br>
- BPDU주고 받는가? ⭕️ <br>
  🥊 근데 새로운 스위치가 접속, 브리지나 스위치의 구성 값이 바뀜 ➡️ 다시 Blocking 상태 <br>
  🥊 고장이 나거나 shutDown 명령 ➡️ 다시 Disabled 상태로 돌아감 <br>

### ✔️ Learning

Listening 상태에 있던 스위치 포트가 **포워딩 딜레이(Forwarding Delay)**디폴트 시간인 15초동안 그 상태를 유지하면 Learning 상태로 <br> 넘어간다. <br>
드디어 맥 어드레스 배울 수 있음. <br>
맥 어드레스 배워서 **맥 어드레스 테이블(브리지 테이블)**을 만든다. <br>

- 데이터 전송 가능? ❌ <br>
- 맥 어드레스 배울 수 있는가? ⭕️ <br>
- BPDU주고 받는가? ⭕️ <br>

🥊 근데 새로운 스위치가 접속, 브리지나 스위치의 구성 값이 바뀜 ➡️ 다시 Blocking 상태 <br>
🥊 고장이 나거나 shutDown 명령 ➡️ 다시 Disabled 상태로 돌아감 <br>

### ✔️ Forwading

계속 루트 포트, 데지그네이티드 포트 포지션을 유지하고, 포워딩 딜레이(Forwarding Delay) 디폴트 시간인 15초동안 그 상태를 유지하면 Forwading 상태로 넘어간다. <br>
포워딩 상태가 되어서야 비로소 포트끼리 데이터 프레임 주고받기 가능 <br>

#### 즉, 블로킹 상태에서 포워딩 상태로 오려면 **디폴트 포워딩 딜레이가 2번 지나 30초 지나야** 가능

디폴트 포워딩 딜레이 시간인 15초를 Listening상태일 때 1번 기다리고, Learning 상태일 때 또 한번 기다려 총 30초 <br>
<br>

- 데이터 전송 가능? ⭕️ <br>
- 맥 어드레스 배울 수 있는가? 맥 어드레스 테이블(브리지 테이블) 만들고 있음⭕️ <br>
- BPDU주고 받는가? ⭕️ <br>

🥊 근데 새로운 스위치가 접속, 브리지나 스위치의 구성 값이 바뀜 ➡️ 다시 Blocking 상태 <br> <br>
🥊 고장이 나거나 shutDown 명령 ➡️ 다시 Disabled 상태로 돌아감 <br> <br>

## 7️⃣ 스패닝 트리에 변화가 생긴다면? 재편성

🔴 루트 브리지, 루트 포트, 데지그네이티드 포트 선정이 끝나 포워딩 상태 <br>
🟠 루트 브리지는 헬로 BPDU를 2초마다 Non Root Bridge로 전달, Non Root Bridge는 이것을 자신의 데지그네이티드 포트 통해 다시 전달 <br>
💥 링크에 문제가 생겨 끊어짐, 🎛️스위치가 헬로 BPDU 못 받음 <br>
🟡 🎛️스위치는 맥스 에이지 기다림. <br>
🟢 기다려도 헬로 BPDU 받지 못하면, 스패닝 트리 재편성 시작 <br>
🔵 🎛️스위치는 다른 스위치에서 전달해 준 헬로 패킷을 자신의 다른 포트🚪로 받음 <br>
🟣 지금 헬로 패킷 받는 포트🚪를 루트 포트로 새로 선정 <br>
⚫️ 단, 루트 포트 새로 선정했다고 바로 포워딩 상태로 넘어가는 것은 아니고, 포워딩 딜레이 시간 15초씩 2번 기다림. <br>

### ⭐️ Hello Time:

루트 브리지가 얼마 만에 한 번씩 헬로 BPDU를 보내는지에 대한 시간.<br>
<br>
루트 브리지는 자신에게 연결된 브리지들에게 헬로 BPDU를 헬로타임마다 한 번씩 보낸다. <br>
디폴트 Hello Time은 2초 <br>

### ⭐️ Max Age:

브리지들이 루트 브리지로부터 얼마 동안 헬로 패킷을 받지 못했을 때 루트 브리지가 죽었다고 생각하고 새로운 스패닝 트리 재편성 시작하는지에 대한 시간<br>
<br>
브리지가 루트 브리지로부터 헬로 패킷 받지 못하면 Max Age만큼 기다린 후, 새로운 스패닝 트리 재편성 시작 <br>

### ⭐️ Forwarding Delay:

브리지 포트가 블로킹 상태에서 포워딩 상태로 넘어가는데 걸리는 시간<br>
<br>
폴트 포워딩 딜레이 시간을 Listening상태에서 Learning 상태 넘어갈 때 1번 기다리고, Learning 상태에서 Forwarding 상태로 넘어갈 때 또 한번 기다려 Forwarding Delay 디폴트 타임의 2배가 된다. <br>

## 8️⃣ 카타이스트 스위치란? 구성하기

## 9️⃣ 맥 어드레스를 저장하는 방법

### Dynamic 방식

자동으로 배우는 방식 <br>
스위치나 브리지가 들어오는 맥 어드레스를 보고 자신의 맥 어드레스 테이블에 저장 <br>
주소 테이블에 있는 맥 어드레스를 찾으면 그 쪽 포트로 보내고 나머지 포트는 막음 <br>
콜리전 도메인 막음 <br>
그러다가 이 주소를 사용한지 300초가 지나면 맥 어드레스 테이블에서 지워버림(다 기억할 수는 없으니까, 메모리 확보) <br>
<br>

### Permanent 방식 ➡️ 스태틱 맥 어드레스

사람이 수동으로 값 저장 <br>
항상 맥 어드레스 테이블에 저장되어 지워지지 않음 <br>
이 맥 어드레스 알기 위해 Learning과정을 거칠 필요가 없음 <br>
그러나 주소가 바뀌면 자동으로 수정 불가, 메모리 낭비 <br>

## 🔟 가상의 랜 Virtual Lan

![이름 없는 노트북-12](https://github.com/soheeparklee/sc_project_carrotMkt_improved/assets/97790983/f635550e-d9fb-4e2d-b9bd-3fcd7856a52c)

### Virtual Lan은 스위치의 기능

같은 VLAN끼리는 스위치를 건너서 통신 <br>
VLAN간의 통신은 라우터를 통해서만 가능 <br>

### Virtual Lan은 한 대의 스위치를 여러 대의 네트워크로 나누기 위해 사용

- Virtual Lan을 사용하면 한 대의 스위치를 마치 여러 대의 분리된 스위치처럼 사용 가능 <br>
- 한개의 포트에 여러 개의 네트워크 정보를 보내는 것이 가능하다. <br>

#### 스위치를 VLAN으로 나누는 방법

**Static VLAN 방법** <br>
스위치의 각 포트들을 원하는 VLAN에 하나씩 배정 <br>
<br>
**Dinamic VLAN 방법** <br>
VMPS가 그 포트에 접속하는 장비의 맥 어드레스의 VLAN을 보고 그 주소에 따라 VLAN을 달리 배정 <br>
VMPS: VLAN Membership Policy Server <br>
스위치는 Learning 기능을 사용해 장비의 맥 어드레스 배움 <br>
맥 어드레스를 VMPS에게 전달 <br>
VMPS는 자신의 데이터베이스를 뒤져 방금 들어온 맥 어드레스에 해당하는 VLAN을 찾아 다시 스위치에게 전달 <br>
그러면 VLAN값을 받은 스위치는 그 장비의 VLAN를 방금 받은 값으로 저장 <br>

### Virtual Lan: 스위치 안에 있는 각각의 스위치

### 🚪🚛 Trunk Port: 트렁크 포트

하나의 포트를 통해 서로 다른 여러 개의 VLAN을 전송할 수 있게 하는 포트
스위치 사이를 패스트 이더넷 포트틑 통해 연결 <br>

## 🚛 트렁킹

여러 개의 VLAN을 한 번에 전송하는 방식 <br>
VLAN이 하나의 링크를 통해 다른 스위치나 라우터로 이동 <br>
이동해서 주소 잘 찾아가기 위해 VLAN별로 이름표가 필요함. <br>
이름표 붙이는 방식에 따라 트렁킹이 두 가지 방식으로 나뉨. <br>

#### ISL 트렁킹

시스코에서 만든 트렁킹 프로토콜, 시스코 장비끼리만 사용 <br>
네이티브 VLAN이란 개념 없이, 모든 VLAN은 이름표를 가지고 있다. <br>

#### IEEE 802.1Q방식

크렁킹 표준 프로토콜 <br> <br>
**네이티브 VLAN**: 이름표 달지 않은 딱 한 개의 VLAN <br> <br>

## VTP(VLAN Trunking Protocol)

스위치들 간에 VLAN정보를 서로 주고받아 스위치들이 가지고 있는 VLAN정보를 항상 일치시켜 주기 위한 프로토콜 <br>
시스코 만의 프로토콜 <br>
VTP enabled 되면, VTP서버에서 한 번만 VLAN정보를 변경해도 VTP 서버는 다른 **스위치와의 트렁크 링크 🚛🚪**통해 VLAN정보를 업데이트 <br>
모든 스위치에 일일이 VLAN정보를 업데이트 하지 않아도 VTP서버가 해주니까 짱 편함! 나는 VTP서버만 업데이트 해주면 끝이니까.
<br>
VTP에서의 VLAN정보는 스위치 간 트렁크 링크 🚛🚪 통해서만 전달된다. <br>

### VTP간 주고받는 메세지

#### Summary Advertisement

VTP서버가 자기에게 연결되어 있는 스위치들에게 5분마다 한 번씩 전달하는 메세지 <br>
자신이 관리하는 VTP도메인의 구성에 대한 Revision Number을 보낸다. <br>
스위치들은 이 Revision Number을 보고 자신의 VLAN정보가 최신인지 아닌지 판단 <br>
<br>
또 VLAN 구성에 변화가 생기면 전달, 이 때는 5분마다 아니고 즉시 전달 <br>

#### Subset Advertisement

VLAN 구성이 변경되었을 때 또는 VTP 클라이언트로부터 Advertisement Request을 받았을 때 전송 <br>
실제 VLAN정보는 바로 이 Subset Advertisement에 저장되어 전달 <br>

#### Advertisement Request

클라리언트가 VTP서버에게 Summary Advertisement, Subset Advertisement 요청하는 용도 <br>

### VTP의 세 가지 모드

#### VTP 서버 모드:

VLAN 생성, 삭제, 이름 바꾸기 <br>
VTP 도메인 안에 있는 나머지 스위치에게 VTP 도메인 이름, VTP구성, configuration revision넘버 전달 <br>
VTP서버는 VLAN정보를 NVRAM에 저장 <br>

#### VTP 클라이언트 모드:

VTP 서버가 전달해 준 VLAN정보 받고, <br>
또 받은 정보를 자신과 연결된 다른쪽 스위치에 전달 <br>
따로 VLAN정보를 저장하지 않음 <br>

#### VTP Transparent 모드:

VTP도메인 영역 안에 있기는 하지만 ⭕️ <br>
VTP 서버로부터 메세지를 받아 자신의 VLAN을 업데이트하거나 자신의 VLAN정보를 전달하지 않음 ❌ <br>
자신과 연결된 다른 스위치쪽에서 서버쪽으로 가는 VTP메세지(3가지 Advertisement)를 전달해주는 역할 ⭕️ <br>
직접 VLAN을 만들고, 삭제하고, 다른 스위치들에게 자신의 VLAN정보 알리지 않음 <br>
