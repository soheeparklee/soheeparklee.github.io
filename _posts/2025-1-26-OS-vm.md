---
title: KOCW_Virtual Memory
categories: [Computer Science, Computer Architecture/Operating System]
tags: [] # TAG names should always be lowercase
---

- 물리적 메모리의 주소변환은 OS가 관여하지 않는다
- Virtual Memory기법은 OS가 전적으로 관여한다

- 💡 `Virtual Memory` 여기서는 `paging`기법을 사용한다고 가정하고 아래 모두를 설명한다
- 실제로 현대적인 프로그램은 `paging`기법을 주로 사용

## ✅ Demand Paging

> `demand`가 있으면 그 페이지를 `paging`, 즉 `page`에 올리겠다

- **실제로 필요할 때** `page`를 메모리에 올리는 것
- 요청이 되었을 때 `address translation`을 하고 `page`에 올린다
- 필요한 프로세스만 메모리에 올린다

  - 👍🏻 I/O양의 감소
  - 👍🏻 `physical memory` 사용량 감소
  - 👍🏻 빠른 응답 시간
  - 👍🏻 더 많은 사용자 수용 가능
  - 👍🏻 더 많은 프로그램을 메모리에 올릴 수 있음

<img width="400" alt="Image" src="https://github.com/user-attachments/assets/d49ac693-fa6e-4949-855b-d583a791c154" />

- `valid bit`, `invalid bit` 사용
- `invalid`:
  - 1️⃣ 사용되지 않는 주소공간이다
  - 2️⃣ 페이지가 물리적 메모리에 없다
- 처음에는 모든 `page entry`가 `invalid`로 초기화, `default`

```
logical memory에 A~H까지 있음
logical memory       page table       physical memory      swap area
   0, A               0, 4, valid         4, A
   1, B               1, X, invalid     안 올라와 있음            B
   2, C               2, 6 valid          6, C
   6, G               6, X, invalid    사용되지 않는 주소공간       X
```

- 사용되지 않는 주소공간이라도 `page table`은 만들어진다
- 그래서 `G`, `H`가 만들어졌지만, 사용되지 않기 때문에 `invalid`이다

#### ☑️ Memory에 없는 page의 page table

- `address translation`시에 `invalid bit`이 `set`되어 있으면
- ➡️ `page fault`

```
CPU에서 프로그램1을 실행하기 위해
address translation이 필요했고
그래서 프로그램1 logical memory를 page table에서 page1을 찾았다
그러나 page1은 invalid로 설정되어 있고, physical memory에 메모리가 안 올라와 있음
그러면 page fault
page1의 값을 메모리에 올리기 위해 I/O작업이 필요하다

page fault가 발생하면
CPU는 OS에게 넘어가게 된다 ➡️ 일종의 interrupt
```

## ✅ Page Fault

> invalid page를 접근하면 **MMU**가 `page fault trap`을 발생시킨다

- CPU가 자동으로 운영체제에게 넘어감
- `kernel mode`로 들어가서 `page fault handler`이 `invoke`됨

#### ☑️ Page Fault Process

- 다음과 같은 순서로 `page fault`처리
- 운영체제가 CPU넘겨받아서 하는 일

<img width="386" alt="Image" src="https://github.com/user-attachments/assets/290d998f-455a-4139-948c-867e54f802d7" />

```
1. 프로세스가 메모리에서 M이라는 값을 불러오려고 함, 그런데 메모리에 값 없음
2. page fault trap발생
    CPU가 자동으로 운영체제에게 넘어감
- 잘못된 메모리 요청이 아닌지 확인, invalid reference?(bad address, protection violation) ➡️ abort process
- get an empty frame(비어있는 프레임 없으면 뺏어온다 replace)
3. 해당 페이지를 disk에서 memory로 읽어온다
    1. disk I/O가 끝나기까지 이 프로세스는 CPU를 preempt 당한다(block)
    2. Disk read가 끝나면 page tables entry기록 valid/invalid bit = "Valid"
    3. ready queue에 process를 insert ➡️ dispatch later
4. bring in missing page to physical memory
- 이 프로세스가 CPU를 잡고 다기 running
5. 페이지 테이블에 추가
6. 아까 중단되었던 instrucion을 재개
```

#### ☑️ Performance of demand paging

- disk에서 프로세스를 읽어오는 건 매우 오래 걸리고 `overhead`가 큰 작업이다
- 대부분은 `page fault`까지 가지 않지만, `page fault`가 나서 메모리에서 값을 읽어올 때는 `overhead`가 비싸다

- Page Fault Rte 0<= `p` <= 1.0
  - if `p` = 0 no page faults
  - if `p` = 1, every reference is a fault

```
Effective Access Time
 =  (1 - p) * memory access
    + (OS & HW page fault overhead)
    + [swap page out if needed] //메모리에 자리 없으면 프로세스 쫒아내기
    + swap page in
    + OS & HW restart overhead
```

## ✅ Page Replacement

> physical memory에 더 이상 자리가 없어 <br>
> 기존 프로세스를 쫒아내고 `empty frame`을 만들어야 하는 상황 <br>

- 어떤 `frame`을 빼앗아올지 결정해야 한다
- 곧바로 사용되지 않을 `page`를 쫒아내는 것이 좋음
- 동일한 `page`가 여러 번 메모리에서 쫒겨났다가 다시 들어올 수도 있음

- ✔️ Page Replacement Algorithm
- `page fault rate`를 최소화하는게 목표
- 알고리즘 평가: 주어진 `page reference string`에 대해 `page fault`를 얼마나 내는지 조사

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅
