---
title: KOCW_File System
categories: [Computer Science, Computer Architecture/Operating System]
tags: [] # TAG names should always be lowercase
---

## ✅ File and File System

> named collection of related inforamtion

- 일반적으로 involataile 보조기억장치에 저장(Harddisk에 저장)
- `file`은 이름으로 접근(🆚 메모리는 주소로 접근)
- OS는 다양한 저장장치를 `file`이라는 동일한 논리적 단위로 볼 수 있게 해 줌
- **File Operation**
  - `create`
  - `read`
  - `write`
  - `reposition(lseek)`: 파일 내 장소를 포인터로 가리킴(현재 수정하고 있는 부분)
  - `delete`
  - `open`: `File attribute`를 메모리에 올려놓기
  - `close` 등

#### ☑️ File attribute(metadata)

> metadata of file

- 파일 자체의 내용 ❌
- 파일을 관리하기 위한 각종 정보
  - 파일 이름, 유형, 저장 위치, 파일 사이즈
  - 접근 권한(`read`, `write`), 시간(생성/변경/사용), 소유자 등

#### ☑️ File System

- **운영체제**에서 파일을 관리하는 부분
- `file`, `file attribute`, `directory info` 관리
- 파일의 저장 방법 결정
- 파일 보호 등

## ✅ Directory and Logical Disk

#### ☑️ Directory

- 파일의 `metadata` 중 일부를 보관하고 있는 일종의 특별한 **파일**
- 그 디렉토리에 속한 파일 이름 및 파일 `attribute`

```
일반 파일: 파일 내용
Directory 파일: 그 Directory 안에 존재하는 파일들의 metadata 저장
```

- **Directory Operation**
  - `search for a file`
  - `create a file`
  - `delete a file`
  - `list a directory`: 그 Directory내에 있는 파일 뭐가 있는지
  - `rename a file`: 그 Directory내에 있는 파일 이름 바꾸기
  - `traverse the file system`: 파일시스템 전체 탐색

#### ☑️ Partition(Logical Disk)

- 하나의 `physical` 디스크 안에 여러 `partition`을 두는 것이 일반적이다
- 여러 개의 물리적 디스크를 하나의 `partition`으로 구성하기도 함
- `physical` 디스크를 `partition`으로 구성한 뒤
- 각각의 `partition`에 `file system`을 깔거나, `swapping` 등 **다른 용도로 사용** 가능

## 📍 File Operation **Open**

<img width="483" alt="Image" src="https://github.com/user-attachments/assets/6b8b0ec1-b26d-4466-b24d-2a5d5019e42d" />

- 파일의 `metadata`를 디스크에서 메모리에 올려두기
- `system call`의 일종

<img width="473" alt="Image" src="https://github.com/user-attachments/assets/8d7613a6-23bc-40b2-a822-40ed6254322b" />

```
--- 디스크로부터 파일 c의 metadata를 메모리로 가지고 오는 과정 ---

open("a/b/c") system call
CPU제어권이 OS에게 넘어감
process A의 PCB

directory path를 search
root의 metadata를 열면, file a 의 위치 획득
root directory /를 open하여 그 안에서 파일 a위치 획득

file a를 open하고 read하여 파일 b의 위치 획득
file b를 open하고 read하여 파일 c의 위치 획득
open file c
return fd: file descriptor

이 때 바로 프로세스에게 전달하는게 아니라
OS한테 먼저 저장하고, 복사해서 전달
Buffer caching: 그래서 나중에 다른 프로세스가 같은 파일을 요청하면, OS에 있는 값을 복사해서 전달
```

- 👎🏻 `Directory path`의 `search`에 시간이 너무 오래 걸림

  - `open`을 `read`, `write`와 별도로 두는 이유이다
  - 한번 `open`한 파일은 `read`, `write`시 `directory search`불필요

- ✔️ **Open file table**
- 현재 `open`된 파일들의 `metadata` 보관소(in memory)
- 디스크의 `metadata`보다 몇 가지 정보 _추가_
  - `open`한 프로세스의 수
  - `file offset`: 파일의 어느 위치를 접근 중인지 표시(별도 테이블 필요)
- system wide open file table: 시스템에 `open file table`한 개

- ✔️ **File descriptor**
- file handle, file control block
- `open file table`에 대한 위치 정보(프로세스 각각 가지고 있는 테이블)
- per process file descriptor table: 프로세스마다 `metadata`를 가지고 있는 테이블

## ✅ Buffer caching

- OS가 이전에 파일에서 읽어온 값을 `buffer cache`에 저장해 두었다가
- 똑같은 요청이 들어오면 `buffer cache`에서 전달
- 파일 요청은 OS에게 무조건 `system call`을 통해 CPU제어권이 넘어 오기 때문에
- `buffer cache`에 대한 `LRU`는 구현 가능
- 🆚 memory에서는 `page`에 대한 정보를 OS가 다 가지고 있지 않았기 때문에 `LRU`는 구현 불가능했음, `clock algorithm`썼음

## ✅ File Protection

- 각 파일에 대해 **누구에게** 그리고 **어떤 유형의 접근** `read`, `write`, `execution`을 허락할 것인가?

#### ☑️ Access Control 방법

- ✔️ **Access Control Matrix**

<img width="440" alt="Image" src="https://github.com/user-attachments/assets/607c6608-ec8b-4e13-b4f8-6cb1a92c7a3c" />

- 행렬에 `사용자`, `파일`을 정렬해놓고 권한 정리
- 👎🏻 행렬 칸을 모두 만들어야 하니 비효율적
- 💊 `Access Control List`, `Capability`를 `linked list`로 구현

- `Access Control List`: 파일별로 누구에게 어떤 접근권한이 있는지 표시(하나의 file만 `linked list`로 구현)
- `Capability`: 사용자별로 자신이 접근 권한을 가진 파일 및 해당 권한 표시(하나의 user만 `linked list`로 구현)

- ✔️ **Grouping**
- 전체 user을 `owner`, `group`, `public`세 그룹으로 구분
- 각 파일에 대해 세 그룹의 접근 권한 `rwx`를 3비트씩으로 표시
- UNIX에서 사용하는 방식

- ✔️ **Password**
- 파일마다 Password를 두는 방법(디렉토리 파일에 두는 방법도 가능)
- 모든 접근 권한에 대해 하나의 Password(`all or nothing`)
- 👎🏻 접근 권한 별 Password: 암기 문제, 관리 문제

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅

## ✅
